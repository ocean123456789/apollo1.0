# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from novatel_msgs/LOGFILESTATUS.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import novatel_msgs.msg

class LOGFILESTATUS(genpy.Message):
  _md5sum = "74eb235b0db9d292dfd0c8e219308901"
  _type = "novatel_msgs/LOGFILESTATUS"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """# Response for LOGFILESTATUS

novatel_msgs/CommonHeader header

uint32 		file_state

uint32  	filename1
uint32  	filename2
uint32  	filename3
uint32  	filename4
uint32  	filename5
uint32  	filename6
uint32  	filename7
uint32  	filename8
uint32  	filename9
uint32  	filename10
uint32      filename11
uint32  	filename12
uint32  	filename13
uint32  	filename14
uint32  	filename15
uint32  	filename16
uint32  	filename17
uint32  	filename18
uint32  	filename19
uint32  	filename20
uint32  	filename21
uint32  	filename22
uint32  	filename23
uint32  	filename24
uint32  	filename25
uint32  	filename26
uint32  	filename27
uint32  	filename28
uint32  	filename29
uint32  	filename30
uint32  	filename31
uint32  	filename32

uint32 		file_size
uint32 		storage_medium
uint32 		media_free_space
uint32 		media_capacity


================================================================================
MSG: novatel_msgs/CommonHeader
# On the wire, this header is preceeded by three sync bytes,
# which are 0xAA 0x44 0x12, and a uint8 which is the header length.

# Message ID of the log being output.
uint16 id

# Measurement source, format, response bit.
uint8 msg_type

uint8 port_addr
uint16 length
uint16 sequence

uint8 idle_time
uint8 time_status

uint16 gps_week
uint32 gps_week_milliseconds

# Table 3 in the SPAN on OEM6 manual.
# See: http://www.novatel.com/assets/Documents/Manuals/OM-20000144UM.pdf#page=13
uint32 receiver_status
uint32 RECEIVER_STATUS_ERROR=1
uint32 RECEIVER_STATUS_TEMPERATURE_WARNING=2
uint32 RECEIVER_STATUS_VOLTAGE_SUPPLY_WARNING=4
uint32 RECEIVER_STATUS_ANTENNA_UNPOWERED=8
uint32 RECEIVER_STATUS_LNA_FAILURE=16
uint32 RECEIVER_STATUS_ANTENNA_OPEN=32
uint32 RECEIVER_STATUS_ANTENNA_SHORTED=64
uint32 RECEIVER_STATUS_CPU_OVERLOADED=128
uint32 RECEIVER_STATUS_COM1_BUFFER_OVERRUN=256
uint32 RECEIVER_STATUS_COM2_BUFFER_OVERRUN=512
uint32 RECEIVER_STATUS_COM3_BUFFER_OVERRUN=1024
uint32 RECEIVER_STATUS_LINK_OVERLOAD=2048
uint32 RECEIVER_STATUS_AUX_TRANSMIT_OVERRUN=8192
uint32 RECEIVER_STATUS_AGC_OUT_OF_RANGE=16384
uint32 RECEIVER_STATUS_INS_RESET=65536
uint32 RECEIVER_STATUS_ALMANAC_INVALID=262144
uint32 RECEIVER_STATUS_POSITION_SOLUTION_INVALID=524288
uint32 RECEIVER_STATUS_POSITION_NOT_FIXED=1048576
uint32 RECEIVER_STATUS_CLOCK_STEERING_DISABLED=2097152
uint32 RECEIVER_STATUS_CLOCK_MODEL_INVALID=4194304
uint32 RECEIVER_STATUS_EXTERNAL_OSCILLATOR_LOCKED=8388608
uint32 RECEIVER_STATUS_SOFTWARE_RESOURCE_WARNING=16777216
uint32 RECEIVER_STATUS_AUXILIARY3_EVENT=536870912
uint32 RECEIVER_STATUS_AUXILIARY2_EVENT=1073741824
uint32 RECEIVER_STATUS_AUXILIARY1_EVENT=2147483648

uint16 reserved
uint16 software_version

"""
  __slots__ = ['header','file_state','filename1','filename2','filename3','filename4','filename5','filename6','filename7','filename8','filename9','filename10','filename11','filename12','filename13','filename14','filename15','filename16','filename17','filename18','filename19','filename20','filename21','filename22','filename23','filename24','filename25','filename26','filename27','filename28','filename29','filename30','filename31','filename32','file_size','storage_medium','media_free_space','media_capacity']
  _slot_types = ['novatel_msgs/CommonHeader','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32','uint32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,file_state,filename1,filename2,filename3,filename4,filename5,filename6,filename7,filename8,filename9,filename10,filename11,filename12,filename13,filename14,filename15,filename16,filename17,filename18,filename19,filename20,filename21,filename22,filename23,filename24,filename25,filename26,filename27,filename28,filename29,filename30,filename31,filename32,file_size,storage_medium,media_free_space,media_capacity

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(LOGFILESTATUS, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = novatel_msgs.msg.CommonHeader()
      if self.file_state is None:
        self.file_state = 0
      if self.filename1 is None:
        self.filename1 = 0
      if self.filename2 is None:
        self.filename2 = 0
      if self.filename3 is None:
        self.filename3 = 0
      if self.filename4 is None:
        self.filename4 = 0
      if self.filename5 is None:
        self.filename5 = 0
      if self.filename6 is None:
        self.filename6 = 0
      if self.filename7 is None:
        self.filename7 = 0
      if self.filename8 is None:
        self.filename8 = 0
      if self.filename9 is None:
        self.filename9 = 0
      if self.filename10 is None:
        self.filename10 = 0
      if self.filename11 is None:
        self.filename11 = 0
      if self.filename12 is None:
        self.filename12 = 0
      if self.filename13 is None:
        self.filename13 = 0
      if self.filename14 is None:
        self.filename14 = 0
      if self.filename15 is None:
        self.filename15 = 0
      if self.filename16 is None:
        self.filename16 = 0
      if self.filename17 is None:
        self.filename17 = 0
      if self.filename18 is None:
        self.filename18 = 0
      if self.filename19 is None:
        self.filename19 = 0
      if self.filename20 is None:
        self.filename20 = 0
      if self.filename21 is None:
        self.filename21 = 0
      if self.filename22 is None:
        self.filename22 = 0
      if self.filename23 is None:
        self.filename23 = 0
      if self.filename24 is None:
        self.filename24 = 0
      if self.filename25 is None:
        self.filename25 = 0
      if self.filename26 is None:
        self.filename26 = 0
      if self.filename27 is None:
        self.filename27 = 0
      if self.filename28 is None:
        self.filename28 = 0
      if self.filename29 is None:
        self.filename29 = 0
      if self.filename30 is None:
        self.filename30 = 0
      if self.filename31 is None:
        self.filename31 = 0
      if self.filename32 is None:
        self.filename32 = 0
      if self.file_size is None:
        self.file_size = 0
      if self.storage_medium is None:
        self.storage_medium = 0
      if self.media_free_space is None:
        self.media_free_space = 0
      if self.media_capacity is None:
        self.media_capacity = 0
    else:
      self.header = novatel_msgs.msg.CommonHeader()
      self.file_state = 0
      self.filename1 = 0
      self.filename2 = 0
      self.filename3 = 0
      self.filename4 = 0
      self.filename5 = 0
      self.filename6 = 0
      self.filename7 = 0
      self.filename8 = 0
      self.filename9 = 0
      self.filename10 = 0
      self.filename11 = 0
      self.filename12 = 0
      self.filename13 = 0
      self.filename14 = 0
      self.filename15 = 0
      self.filename16 = 0
      self.filename17 = 0
      self.filename18 = 0
      self.filename19 = 0
      self.filename20 = 0
      self.filename21 = 0
      self.filename22 = 0
      self.filename23 = 0
      self.filename24 = 0
      self.filename25 = 0
      self.filename26 = 0
      self.filename27 = 0
      self.filename28 = 0
      self.filename29 = 0
      self.filename30 = 0
      self.filename31 = 0
      self.filename32 = 0
      self.file_size = 0
      self.storage_medium = 0
      self.media_free_space = 0
      self.media_capacity = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_H2B2H2BH2I2H37I.pack(_x.header.id, _x.header.msg_type, _x.header.port_addr, _x.header.length, _x.header.sequence, _x.header.idle_time, _x.header.time_status, _x.header.gps_week, _x.header.gps_week_milliseconds, _x.header.receiver_status, _x.header.reserved, _x.header.software_version, _x.file_state, _x.filename1, _x.filename2, _x.filename3, _x.filename4, _x.filename5, _x.filename6, _x.filename7, _x.filename8, _x.filename9, _x.filename10, _x.filename11, _x.filename12, _x.filename13, _x.filename14, _x.filename15, _x.filename16, _x.filename17, _x.filename18, _x.filename19, _x.filename20, _x.filename21, _x.filename22, _x.filename23, _x.filename24, _x.filename25, _x.filename26, _x.filename27, _x.filename28, _x.filename29, _x.filename30, _x.filename31, _x.filename32, _x.file_size, _x.storage_medium, _x.media_free_space, _x.media_capacity))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = novatel_msgs.msg.CommonHeader()
      end = 0
      _x = self
      start = end
      end += 172
      (_x.header.id, _x.header.msg_type, _x.header.port_addr, _x.header.length, _x.header.sequence, _x.header.idle_time, _x.header.time_status, _x.header.gps_week, _x.header.gps_week_milliseconds, _x.header.receiver_status, _x.header.reserved, _x.header.software_version, _x.file_state, _x.filename1, _x.filename2, _x.filename3, _x.filename4, _x.filename5, _x.filename6, _x.filename7, _x.filename8, _x.filename9, _x.filename10, _x.filename11, _x.filename12, _x.filename13, _x.filename14, _x.filename15, _x.filename16, _x.filename17, _x.filename18, _x.filename19, _x.filename20, _x.filename21, _x.filename22, _x.filename23, _x.filename24, _x.filename25, _x.filename26, _x.filename27, _x.filename28, _x.filename29, _x.filename30, _x.filename31, _x.filename32, _x.file_size, _x.storage_medium, _x.media_free_space, _x.media_capacity,) = _struct_H2B2H2BH2I2H37I.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_H2B2H2BH2I2H37I.pack(_x.header.id, _x.header.msg_type, _x.header.port_addr, _x.header.length, _x.header.sequence, _x.header.idle_time, _x.header.time_status, _x.header.gps_week, _x.header.gps_week_milliseconds, _x.header.receiver_status, _x.header.reserved, _x.header.software_version, _x.file_state, _x.filename1, _x.filename2, _x.filename3, _x.filename4, _x.filename5, _x.filename6, _x.filename7, _x.filename8, _x.filename9, _x.filename10, _x.filename11, _x.filename12, _x.filename13, _x.filename14, _x.filename15, _x.filename16, _x.filename17, _x.filename18, _x.filename19, _x.filename20, _x.filename21, _x.filename22, _x.filename23, _x.filename24, _x.filename25, _x.filename26, _x.filename27, _x.filename28, _x.filename29, _x.filename30, _x.filename31, _x.filename32, _x.file_size, _x.storage_medium, _x.media_free_space, _x.media_capacity))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = novatel_msgs.msg.CommonHeader()
      end = 0
      _x = self
      start = end
      end += 172
      (_x.header.id, _x.header.msg_type, _x.header.port_addr, _x.header.length, _x.header.sequence, _x.header.idle_time, _x.header.time_status, _x.header.gps_week, _x.header.gps_week_milliseconds, _x.header.receiver_status, _x.header.reserved, _x.header.software_version, _x.file_state, _x.filename1, _x.filename2, _x.filename3, _x.filename4, _x.filename5, _x.filename6, _x.filename7, _x.filename8, _x.filename9, _x.filename10, _x.filename11, _x.filename12, _x.filename13, _x.filename14, _x.filename15, _x.filename16, _x.filename17, _x.filename18, _x.filename19, _x.filename20, _x.filename21, _x.filename22, _x.filename23, _x.filename24, _x.filename25, _x.filename26, _x.filename27, _x.filename28, _x.filename29, _x.filename30, _x.filename31, _x.filename32, _x.file_size, _x.storage_medium, _x.media_free_space, _x.media_capacity,) = _struct_H2B2H2BH2I2H37I.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_H2B2H2BH2I2H37I = struct.Struct("<H2B2H2BH2I2H37I")
