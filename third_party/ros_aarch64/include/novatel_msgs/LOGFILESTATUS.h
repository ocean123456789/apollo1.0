// Generated by gencpp from file novatel_msgs/LOGFILESTATUS.msg
// DO NOT EDIT!


#ifndef NOVATEL_MSGS_MESSAGE_LOGFILESTATUS_H
#define NOVATEL_MSGS_MESSAGE_LOGFILESTATUS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <novatel_msgs/CommonHeader.h>

namespace novatel_msgs
{
template <class ContainerAllocator>
struct LOGFILESTATUS_
{
  typedef LOGFILESTATUS_<ContainerAllocator> Type;

  LOGFILESTATUS_()
    : header()
    , file_state(0)
    , filename1(0)
    , filename2(0)
    , filename3(0)
    , filename4(0)
    , filename5(0)
    , filename6(0)
    , filename7(0)
    , filename8(0)
    , filename9(0)
    , filename10(0)
    , filename11(0)
    , filename12(0)
    , filename13(0)
    , filename14(0)
    , filename15(0)
    , filename16(0)
    , filename17(0)
    , filename18(0)
    , filename19(0)
    , filename20(0)
    , filename21(0)
    , filename22(0)
    , filename23(0)
    , filename24(0)
    , filename25(0)
    , filename26(0)
    , filename27(0)
    , filename28(0)
    , filename29(0)
    , filename30(0)
    , filename31(0)
    , filename32(0)
    , file_size(0)
    , storage_medium(0)
    , media_free_space(0)
    , media_capacity(0)  {
    }
  LOGFILESTATUS_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , file_state(0)
    , filename1(0)
    , filename2(0)
    , filename3(0)
    , filename4(0)
    , filename5(0)
    , filename6(0)
    , filename7(0)
    , filename8(0)
    , filename9(0)
    , filename10(0)
    , filename11(0)
    , filename12(0)
    , filename13(0)
    , filename14(0)
    , filename15(0)
    , filename16(0)
    , filename17(0)
    , filename18(0)
    , filename19(0)
    , filename20(0)
    , filename21(0)
    , filename22(0)
    , filename23(0)
    , filename24(0)
    , filename25(0)
    , filename26(0)
    , filename27(0)
    , filename28(0)
    , filename29(0)
    , filename30(0)
    , filename31(0)
    , filename32(0)
    , file_size(0)
    , storage_medium(0)
    , media_free_space(0)
    , media_capacity(0)  {
  (void)_alloc;
    }



   typedef  ::novatel_msgs::CommonHeader_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _file_state_type;
  _file_state_type file_state;

   typedef uint32_t _filename1_type;
  _filename1_type filename1;

   typedef uint32_t _filename2_type;
  _filename2_type filename2;

   typedef uint32_t _filename3_type;
  _filename3_type filename3;

   typedef uint32_t _filename4_type;
  _filename4_type filename4;

   typedef uint32_t _filename5_type;
  _filename5_type filename5;

   typedef uint32_t _filename6_type;
  _filename6_type filename6;

   typedef uint32_t _filename7_type;
  _filename7_type filename7;

   typedef uint32_t _filename8_type;
  _filename8_type filename8;

   typedef uint32_t _filename9_type;
  _filename9_type filename9;

   typedef uint32_t _filename10_type;
  _filename10_type filename10;

   typedef uint32_t _filename11_type;
  _filename11_type filename11;

   typedef uint32_t _filename12_type;
  _filename12_type filename12;

   typedef uint32_t _filename13_type;
  _filename13_type filename13;

   typedef uint32_t _filename14_type;
  _filename14_type filename14;

   typedef uint32_t _filename15_type;
  _filename15_type filename15;

   typedef uint32_t _filename16_type;
  _filename16_type filename16;

   typedef uint32_t _filename17_type;
  _filename17_type filename17;

   typedef uint32_t _filename18_type;
  _filename18_type filename18;

   typedef uint32_t _filename19_type;
  _filename19_type filename19;

   typedef uint32_t _filename20_type;
  _filename20_type filename20;

   typedef uint32_t _filename21_type;
  _filename21_type filename21;

   typedef uint32_t _filename22_type;
  _filename22_type filename22;

   typedef uint32_t _filename23_type;
  _filename23_type filename23;

   typedef uint32_t _filename24_type;
  _filename24_type filename24;

   typedef uint32_t _filename25_type;
  _filename25_type filename25;

   typedef uint32_t _filename26_type;
  _filename26_type filename26;

   typedef uint32_t _filename27_type;
  _filename27_type filename27;

   typedef uint32_t _filename28_type;
  _filename28_type filename28;

   typedef uint32_t _filename29_type;
  _filename29_type filename29;

   typedef uint32_t _filename30_type;
  _filename30_type filename30;

   typedef uint32_t _filename31_type;
  _filename31_type filename31;

   typedef uint32_t _filename32_type;
  _filename32_type filename32;

   typedef uint32_t _file_size_type;
  _file_size_type file_size;

   typedef uint32_t _storage_medium_type;
  _storage_medium_type storage_medium;

   typedef uint32_t _media_free_space_type;
  _media_free_space_type media_free_space;

   typedef uint32_t _media_capacity_type;
  _media_capacity_type media_capacity;




  typedef boost::shared_ptr< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> const> ConstPtr;

}; // struct LOGFILESTATUS_

typedef ::novatel_msgs::LOGFILESTATUS_<std::allocator<void> > LOGFILESTATUS;

typedef boost::shared_ptr< ::novatel_msgs::LOGFILESTATUS > LOGFILESTATUSPtr;
typedef boost::shared_ptr< ::novatel_msgs::LOGFILESTATUS const> LOGFILESTATUSConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace novatel_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'nav_msgs': ['/home/ubuntu/baidu/adu-lab/apollo/third_party/ros/share/nav_msgs/cmake/../msg'], 'std_msgs': ['/home/ubuntu/baidu/adu-lab/apollo/third_party/ros/share/std_msgs/cmake/../msg'], 'actionlib_msgs': ['/home/ubuntu/baidu/adu-lab/apollo/third_party/ros/share/actionlib_msgs/cmake/../msg'], 'geometry_msgs': ['/home/ubuntu/baidu/adu-lab/apollo/third_party/ros/share/geometry_msgs/cmake/../msg'], 'novatel_msgs': ['/home/ubuntu/baidu/adu-lab/apollo/modules/ros/novatel_msgs/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "74eb235b0db9d292dfd0c8e219308901";
  }

  static const char* value(const ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x74eb235b0db9d292ULL;
  static const uint64_t static_value2 = 0xdfd0c8e219308901ULL;
};

template<class ContainerAllocator>
struct DataType< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "novatel_msgs/LOGFILESTATUS";
  }

  static const char* value(const ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Response for LOGFILESTATUS\n\
\n\
novatel_msgs/CommonHeader header\n\
\n\
uint32 		file_state\n\
\n\
uint32  	filename1\n\
uint32  	filename2\n\
uint32  	filename3\n\
uint32  	filename4\n\
uint32  	filename5\n\
uint32  	filename6\n\
uint32  	filename7\n\
uint32  	filename8\n\
uint32  	filename9\n\
uint32  	filename10\n\
uint32      filename11\n\
uint32  	filename12\n\
uint32  	filename13\n\
uint32  	filename14\n\
uint32  	filename15\n\
uint32  	filename16\n\
uint32  	filename17\n\
uint32  	filename18\n\
uint32  	filename19\n\
uint32  	filename20\n\
uint32  	filename21\n\
uint32  	filename22\n\
uint32  	filename23\n\
uint32  	filename24\n\
uint32  	filename25\n\
uint32  	filename26\n\
uint32  	filename27\n\
uint32  	filename28\n\
uint32  	filename29\n\
uint32  	filename30\n\
uint32  	filename31\n\
uint32  	filename32\n\
\n\
uint32 		file_size\n\
uint32 		storage_medium\n\
uint32 		media_free_space\n\
uint32 		media_capacity\n\
\n\
\n\
================================================================================\n\
MSG: novatel_msgs/CommonHeader\n\
# On the wire, this header is preceeded by three sync bytes,\n\
# which are 0xAA 0x44 0x12, and a uint8 which is the header length.\n\
\n\
# Message ID of the log being output.\n\
uint16 id\n\
\n\
# Measurement source, format, response bit.\n\
uint8 msg_type\n\
\n\
uint8 port_addr\n\
uint16 length\n\
uint16 sequence\n\
\n\
uint8 idle_time\n\
uint8 time_status\n\
\n\
uint16 gps_week\n\
uint32 gps_week_milliseconds\n\
\n\
# Table 3 in the SPAN on OEM6 manual.\n\
# See: http://www.novatel.com/assets/Documents/Manuals/OM-20000144UM.pdf#page=13\n\
uint32 receiver_status\n\
uint32 RECEIVER_STATUS_ERROR=1\n\
uint32 RECEIVER_STATUS_TEMPERATURE_WARNING=2\n\
uint32 RECEIVER_STATUS_VOLTAGE_SUPPLY_WARNING=4\n\
uint32 RECEIVER_STATUS_ANTENNA_UNPOWERED=8\n\
uint32 RECEIVER_STATUS_LNA_FAILURE=16\n\
uint32 RECEIVER_STATUS_ANTENNA_OPEN=32\n\
uint32 RECEIVER_STATUS_ANTENNA_SHORTED=64\n\
uint32 RECEIVER_STATUS_CPU_OVERLOADED=128\n\
uint32 RECEIVER_STATUS_COM1_BUFFER_OVERRUN=256\n\
uint32 RECEIVER_STATUS_COM2_BUFFER_OVERRUN=512\n\
uint32 RECEIVER_STATUS_COM3_BUFFER_OVERRUN=1024\n\
uint32 RECEIVER_STATUS_LINK_OVERLOAD=2048\n\
uint32 RECEIVER_STATUS_AUX_TRANSMIT_OVERRUN=8192\n\
uint32 RECEIVER_STATUS_AGC_OUT_OF_RANGE=16384\n\
uint32 RECEIVER_STATUS_INS_RESET=65536\n\
uint32 RECEIVER_STATUS_ALMANAC_INVALID=262144\n\
uint32 RECEIVER_STATUS_POSITION_SOLUTION_INVALID=524288\n\
uint32 RECEIVER_STATUS_POSITION_NOT_FIXED=1048576\n\
uint32 RECEIVER_STATUS_CLOCK_STEERING_DISABLED=2097152\n\
uint32 RECEIVER_STATUS_CLOCK_MODEL_INVALID=4194304\n\
uint32 RECEIVER_STATUS_EXTERNAL_OSCILLATOR_LOCKED=8388608\n\
uint32 RECEIVER_STATUS_SOFTWARE_RESOURCE_WARNING=16777216\n\
uint32 RECEIVER_STATUS_AUXILIARY3_EVENT=536870912\n\
uint32 RECEIVER_STATUS_AUXILIARY2_EVENT=1073741824\n\
uint32 RECEIVER_STATUS_AUXILIARY1_EVENT=2147483648\n\
\n\
uint16 reserved\n\
uint16 software_version\n\
\n\
";
  }

  static const char* value(const ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.file_state);
      stream.next(m.filename1);
      stream.next(m.filename2);
      stream.next(m.filename3);
      stream.next(m.filename4);
      stream.next(m.filename5);
      stream.next(m.filename6);
      stream.next(m.filename7);
      stream.next(m.filename8);
      stream.next(m.filename9);
      stream.next(m.filename10);
      stream.next(m.filename11);
      stream.next(m.filename12);
      stream.next(m.filename13);
      stream.next(m.filename14);
      stream.next(m.filename15);
      stream.next(m.filename16);
      stream.next(m.filename17);
      stream.next(m.filename18);
      stream.next(m.filename19);
      stream.next(m.filename20);
      stream.next(m.filename21);
      stream.next(m.filename22);
      stream.next(m.filename23);
      stream.next(m.filename24);
      stream.next(m.filename25);
      stream.next(m.filename26);
      stream.next(m.filename27);
      stream.next(m.filename28);
      stream.next(m.filename29);
      stream.next(m.filename30);
      stream.next(m.filename31);
      stream.next(m.filename32);
      stream.next(m.file_size);
      stream.next(m.storage_medium);
      stream.next(m.media_free_space);
      stream.next(m.media_capacity);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct LOGFILESTATUS_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::novatel_msgs::LOGFILESTATUS_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::novatel_msgs::CommonHeader_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "file_state: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.file_state);
    s << indent << "filename1: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename1);
    s << indent << "filename2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename2);
    s << indent << "filename3: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename3);
    s << indent << "filename4: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename4);
    s << indent << "filename5: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename5);
    s << indent << "filename6: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename6);
    s << indent << "filename7: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename7);
    s << indent << "filename8: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename8);
    s << indent << "filename9: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename9);
    s << indent << "filename10: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename10);
    s << indent << "filename11: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename11);
    s << indent << "filename12: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename12);
    s << indent << "filename13: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename13);
    s << indent << "filename14: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename14);
    s << indent << "filename15: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename15);
    s << indent << "filename16: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename16);
    s << indent << "filename17: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename17);
    s << indent << "filename18: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename18);
    s << indent << "filename19: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename19);
    s << indent << "filename20: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename20);
    s << indent << "filename21: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename21);
    s << indent << "filename22: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename22);
    s << indent << "filename23: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename23);
    s << indent << "filename24: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename24);
    s << indent << "filename25: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename25);
    s << indent << "filename26: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename26);
    s << indent << "filename27: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename27);
    s << indent << "filename28: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename28);
    s << indent << "filename29: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename29);
    s << indent << "filename30: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename30);
    s << indent << "filename31: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename31);
    s << indent << "filename32: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.filename32);
    s << indent << "file_size: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.file_size);
    s << indent << "storage_medium: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.storage_medium);
    s << indent << "media_free_space: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.media_free_space);
    s << indent << "media_capacity: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.media_capacity);
  }
};

} // namespace message_operations
} // namespace ros

#endif // NOVATEL_MSGS_MESSAGE_LOGFILESTATUS_H
